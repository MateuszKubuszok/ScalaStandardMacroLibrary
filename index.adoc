// 35 minutes
:revealjs_totalTime: 1800
:revealjs_theme: serif
:revealjs_help: true

[.small]
= Can we have the{nbsp}Standard Library for{nbsp}Macros?

---

**Mateusz Kubuszok**

[NOTE.speaker]
--
Before answering the question in the title, we need to explain a few more things.
--

== What is a Macro?

[NOTE.speaker]
--
First of all, what is a{nbsp}macro?
--

=== !

[%step]
 * a code generator
 * run during compilation by the compiler
 * working on the AST
 * _pretending_ to be a method
 * `Mirror` s, `inline if` s, `inline match` , `summonInline` , `summonFrom` , ... - metaprogramming but not macros

[NOTE.speaker]
--
...in other words the thing in the next slide.
--

=== !

[.small]
[source, scala]
--
// Scala 2
import scala.language.experimental.macros

def macroMethod[A](a: A): SthOf[A] =
  macro macroMethodImpl[A]

import scala.reflect.macros.blackbox

def macroMethodImpl[A: c.WeakTypeTag](
  c: blackbox.Context
)(a: c.Expr[A]): c.Expr[SthOf[A]] = {
  import c.universe._
  ...
}
--

[.small]
[source, scala]
--
// Scala 3
import scala.quoted.*

inline def macroMethod[A](a: A): SthOf[A] =
  ${ macroMethodImpl[A]('{ a }) }

def macroMethodImpl[A: Type](
  using q: Quotes
)(a: Expr[A]): Expr[SthOf[A]] = {
  import q.reflect.*
  ...
}
--

[NOTE.speaker]
--
This is what I would mean, when I am talking about macros.
--

== Why do we need macros?

[NOTE.speaker]
--
Perhaps we don't, and this whole presentation is pointless.

What alternatives we have?
--

=== Alternatives

[%step]
 * Shapeless (Scala 2)
 * `inline` , Mirrors & `scala.compiletime` (Scala{nbsp}3)
 * Magnolia (Scala 2 & 3)
 * runtime reflection
 
[NOTE.speaker]
--
`Shapeless` and `Mirror` s, usually both rely on summoning implicits, and we end up doing a prolog-like programming with method signatures. 

Magnolia on Scala 2 requires calling a macro, but we don't need to write it, we write some runtime methods.

Runtime moves all magic to the runtime, so we have to run the code to make sure it works.

All 4 of them have gentler learning curves that macros, which is why tutorials favor them.

And why especially the first 3 dominated the Scala ecosystem.
--

=== But

=== !

(slajd na przykłady z errorami, benchmarkami kompilacji i runtime)

=== !

(slajd na przykład z logami z makra)

=== In other words

=== Shapeless/Mirrors/etc

[cols="1,1"]
|===
| You
| Your users
a|
[%step]
 * easy start
 * rapid development
 * everything feels lean
 * everything feels prinicipled and correct
a|
[%step]
 * pay with longer compilation times
 * pay with less performant runtime
 * pay with more time spend if the code doesn't work
|===

[NOTE.speaker]
--
When I look at this, and think of all the popular libraries based on that, I feel like they are:

 * widely-adopted
 * feature-rich
 * proof-of-concept-level quality
 * liabilities
--

=== Macros

[.small]
[cols="1,1"]
|===
| You
| Your users
a|
[%step]
 * longer setup
 * no batteries included
 * development feel clunky
 * everything feels like a hack
a|
[%step]
 * _may_ get better compilation times (than alternatives)
 * _may_ get more performant runtime
 * _may_ get better errors messages
 * *or* may get an undebugabble mess that cannot be understood even by the author
|===

[NOTE.speaker]
--
(Between *may* and *or*) - and our users deserve it!

So this on the other hands is like a hazard game.

If you want to provide:
 * nice compilation times
 * nice runtime performance
 * nice errors messages and debugging experience

then macros are the only game in town.

But with no guarantee of success.

It may sound unfounded, especially since Scala 3 macros are supposedly principled, so let's take a look at some examples.
--

== Macros API

**Opportunities for improvement**

=== Quoting and Splicing

[cols="1,1"]
|===
| Scala 2 (Quasiquotes)
| Scala 3 (Quotes)
a|
[source, scala]
--
// using Quotes
val expr1 =
  c.Expr[Int](q"21")
val expr2 =
  c.Expr[Int](q"37")

val expr3 = c.Expr[Int](
  q"""
  ${ expr1 } + ${ expr2 }
  """
)
--
a|
[source, scala]
--
// using Quotes
val expr1 = Expr(21)
val expr2 = Expr(37)

val expr3 = '{
  ${ expr1 } + ${ expr2 }
}
--
|===

[NOTE.speaker]
--
On Scala 2, if we want to use types, we are very verbose.

Types are not inferred, and we have to use `c.Type` and `c.Expr` to get them.

Quasiquotes are basically compile-time-checked string interpolation,
so even though they are powerful and usually safe,
we have no syntax highlighting, nor intellisense when writing them.

On Scala 3, we have some actual quotes, which works bettern with IDE.

So, this looks like an issue only for Scala 2.
--

=== Matching Types

[.small]
[cols="1,1"]
|===
| Scala 2 (Quasiquotes)
| Scala 3 (Quotes)
a|
[source, scala]
--
def whenOptionOf[A:c.WeakTypeTag] =...

weakTypeOf[A]
 .dealias
 .widen
 .baseType(
  c.mirror.staticClass("scala.Option")
 ) match {
  case TypeRef(_, _, List(t)) =>
    whenOptionOf(
      c.WeakTypeTag(t.dealias.widen)
    )
  case _ => ...
}
--
a|
[source, scala]
--
def whenOptionOf[A: Type] = ...

Type.of[A] match {
  case '[Option[t]] =>
    whenOptionOf[t]
  case _ => ...
}
--
|===

[NOTE.speaker]
--
We want to pattern match on types. Is the type `A` an example of an `Option`?
We also want to handle cases like `None`.

The Scala 2 snippet barely fit in the table.

Scala 3 is quotes easy to read.
--

=== Instantiating an{nbsp}Arbitrary Type

[cols="1,1"]
|===
| Scala 2 (Quasiquotes)
| Scala 3 (Quotes)
a|
[source, scala]
--
val args:List[List[c.Tree]]=
  ...

c.Expr[A](
  q"""
  new ${weakTypeOf[A]}(
    ...${args}
  )
  """
)
--
a|
[source, scala]
--
val ctor = TypeRepr.of[A]
  .typeSymbol
  .primaryConstructor

val args: List[List[Tree]] =
  ...

New(TypeTree.of[A])
  .select(ctor)
  .appliedToArgss(args)
--
|===

[NOTE.speaker]
--
Scala 2 is not perfect, we're gluing untyped `Tree`s, but at least it's consistent.

Scala 3, allows quoting and splicing, but only for whole expressions. Pieces that would build an expression have to be combined manually.
--

=== Constructing a Pattern Match

[.small]
[cols="1,1"]
|===
| Scala 2 (Quasiquotes)
| Scala 3 (Quotes)
a|
[source, scala]
--
def handleCase[
  A: c.WeakTypeTag
](name: c.Expr[A]) = ...
--

[source, scala]
--
/* for each case: */
val name = c.internal
  .reificationSupport
  .freshTermName("a")
cq"""
$name: ${weakTypeOf[A]} =>
  ${handleCase(c.Expr[A](q"$name"))}
"""
--

[source, scala]
--
/* then create the match: */
c.Expr[Result](
  q"""
  $expr match { ...${cases} }
  """
)
--
a|
[source, scala]
--
def handleCase[
  A: Tag
](name: Expr[A]) = ...
--

[source, scala]
--
/* for each case: */
val name = Symbol.newBind(
  Symbol.spliceOwner,
  Symbol.freshName("a"),
  Flags.Empty,
  TypeRepr.of[A]
)
CaseDef(
  Bind(
    name,
    Typed(Wildcard(),TypeTree.of[A])),
  None,
  handleCase(Ref(name).asExprOf[A]))
--

[source, scala]
--
Match(expr.asTerm, cases)
  .asExprOf[Result]
--
|===

[NOTE.speaker]
--
Scala 2, again, not perfect, but consistent. We can actually read the code and understand what's going on.

Scala 3, we can get easily lost with the details.

And, these are not even bullet-proof:
for some cases such match would work, but for some it would not,
so we would have to write multiple versions and check which applies.
--

=== Sealed Trait's Children

[.small]
[cols="1,1"]
|===
| Scala 2 (Quasiquotes)
| Scala 3 (Quotes)
a|
[source, scala]
--
TODO
--
a|
[source, scala]
--
TODO
--
|===

[NOTE.speaker]
--

--

=== !

[.small]
[cols="1,1"]
|===
| Scala 2 (Quasiquotes)
| Scala 3 (Quotes)
a|
[%step]
 * glueing strings instead of typed code
 * but at least these string resemble the real code
 * and compiler checks them
a|
[%step]
 * gluing expressions as every other real code
 * but it's not an expression, we are gluing together untyped trees
|===

[NOTE.speaker]
--
It seems that the API is lacking.

What other issues we might have?
--

== No `println` debugging

[.small]
[cols="1,1"]
|===
| Macro reporting
a| `println`
a|
[source, scala]
--
c.echo("msg") // Scala 2
report.info("msg") // Scala 3
--
a|
[source, scala]
--
println("msg")
--
a|
[%step]
 * works in the terminal
 * works in the IDE
 * works in Scastie
 * logs only the first message from the macro
a|
[%step]
 * prints every time
 * works only in the terminal
 * unless we are using some compilation server
|===

[NOTE.speaker]
--
Macros on both Scala 2 and 3 have reporting mechanisms, which allow showing some hints in the terminal, or in the IDE, or even Scastie.

But if we use `println`, it works only in the terminal. And only if we are not using some compilation server.

Problem with the macro reporting API, is that only the first message is shown.

So, we would have to aggregate the messages somehow, before calling the API only once.
--

== Avoiding runtime dependencies in macros

[%step]
 * no Cats
 * no ZIO
 * nor any other library, that could be used in runtime

[NOTE.speaker]
--
It would be silly if some of our code stopped compiling, because there was a major release of a large library, that we used in some other part of our code.
Or the opposite, if the author of macros forced us to update our dependancy to a new major version, just to fix an unrelated bug.

Unless macro creates a value type that comes from some library used in runtime, it should not have dependency on that library.

But it we had a library that is not intended for runtime, then there is no conflict.
--

== Let us imagine a better API

=== Macro IO

[source, scala]
--
val a = MIO {
  21
}
val b = MIO {
  37
}

a.map2(b)(_ + _) // applicative syntax
--

[source, scala]
--
for {
  i <- MIO(1)
  j <- MIO(2)
} yield i + j // monadic syntax
--

[source, scala]
--
List("1", "2", "3", "a", "b").parTraverse { a =>
  MIO(a.toInt)
} // .par* aggregates errors
--

[NOTE.speaker]
--
First of all, let's image that we can use `IO`-like data type.

It's lazy, non-memoizable, stack-safe, and has all the nice utilities that we expect from `IO`.

It is, of course, completely optional. But if you're into it, then logging would also easy.
--

=== Logging

[source, scala]
--
Log.namedScope("All logs here will share the same span") {
  Log.info("Some operation starting") >> // standalone log

    MIO("some operation")
      .log.info("Some operation ended") >> // log after IO

    Log.namedScope("Spans can be nested") {
      Log.info("Nested log") // we can nest as much as we want
    }
}
--

[source]
--
All logs here will share the same span:
├ [Info]  Some operation starting
├ [Info]  Some operation ended
└ Spans can be nested:
  └ [Info]  Nested log
--

[NOTE.speaker]
--
We could imagine that we can treat logging as a MIO effect.

And since we might decide to use spans, to give it some structure
--

=== Let's assume that it can be a thing

[source, scala]
--
// Yet another utility, because .map/.flatMap
// cannot handle this:
MIO.async { await =>

  Expr.quote { // <- instead of '{}/ q"..."
    new Show[A] {

     def show(a: A): String = Expr.splice {// <- instead of ${}
        await {
          deriveShowBody(Expr.quote{ a })// : MIO[Expr[String]]
        }
      }
    }
  }
}
--

[NOTE.speaker]
--
Syntaxes for Quotes and Quasiquotes seems like something that cannot be reconciled.
But let us imagine that they can.

Let us also imagine, that we have such a "direct style" available to us. Because
we can easily come up with situations, where it would be more convenient than monadic API.
Or where monadic API would be simply impossible.
--

=== And this as well:

[source, scala]
--
val OptionType = Type.Ctor1.of[Option]
val EitherType = Type.Ctor2.of[Either]

Type[A] match {
  case OptionType(a) =>
    ... // a is A in Option[A]
  case EitherType(l, r) =>
    ... // l is L and r is R in Either[L, R]
  case _ =>
    ... // A is not an Option or Either
}
--

=== Imagine you created instances like this:

[.small]
[source, scala]
--
CaseClass.parse[A] match {
  case Some(caseClass) =>
   // A(summon[Arg1], summon[Arg2], ...)
   caseClass.construct { parameter =>
      import parameter.tpe.Underlying as Param

      Expr.summonImplicit[Param] match {
        case Some(expr) => MIO.pure(expr)

        case None => MIO.fail(
          new Exception(s"No implicit for ${Type.prettyPrint[Param]}")
        )
      }
   }

  case None => MIO.fail(
    new Exception(s"Not a case class: ${Type.prettyPrint[A]}")
  )
} // : MIO[Expr[A]]
--

=== And pattern-matched like this:

[.small]
[source, scala]
--
Enum.parse[A] match {
  case Some(enumm) =>

    // expr match {
    //   case b: B => "B" + " : " + b.toString
    //   ...
    // }
    enumm.matchOn(expr) { matchedSubtype =>
      import matchedSubtype.{Underlying as B, value as b}
      val bName = Expr(Type.simpleName[B])
      MIO {
        Expr.quote {
          Expr.splice { b } + " : " + Expr.splice { bName }
        }
      }
    }

  case None => Expr("")
} // : MIO[Expr[String]]
--

== Actually, it's already possible

[.small-h2]
=== Regular code

[.small]
[source, scala]
--
package demo

trait Show[A] extends Show[A] {

  def show(value: A): String
}

object Show extends ShowCompanionCompat // Will provide .derived[A]
--

[.small-h2]
=== Cross-compilable macro

[.small]
[source, scala]
--
package demo

import hearth.*
import fp.effect.*, fp.instances.*, fp.syntax.*

private[demo] trait ShowMacrosImpl { this: MacroCommons =>

  def deriveTypeClass[A: Type]: Expr[Show[A]] = Expr.quote {
    new Show[A] {
      def show(value: A): String = Expr.splice {
        deriveOrFail[A](Expr.quote(value))
      }
    }
  }

  private def deriveOrFail[A: Type](
    value: Expr[A]
  ): Expr[String] = ...
  // ...
}
--

[.small-h2]
=== Adapters

[.small]
[source, scala]
--
package demo

import scala.language.experimental.macros
import scala.reflect.macros.blackbox

private[demo] trait ShowCompanionCompat { this: Show.type =>

  def derived[A]: Show[A] = macro ShowMacros.deriveTypeClassImpl[A]
}

private[demo] class ShowMacros(val c: blackbox.Context)
    extends hearth.MacroCommonsScala2
    with ShowMacrosImpl {

  def deriveTypeClassImpl[A: c.WeakTypeTag]: c.Expr[Show[A]] = deriveTypeClass[A]
}
--

[.small]
[source, scala]
--
package demo

import scala.quoted.*

private[demo] trait ShowCompanionCompat { this: Show.type =>

  inline derived[A]: Show[A] = ${ ShowMacros.deriveTypeClass[A] }
}

private[demo] class ShowMacros(q: Quotes)
    extends hearth.MacroCommonsScala3(using q), ShowMacrosImpl

private[demo] object ShowMacros {

  def deriveTypeClass[A: Type](using q: Quotes): Expr[Show[A]] =
    new ShowMacros(q).deriveTypeClass[A]
}
--

=== !

[.small]
[source, scala]
--
sealed private[demo] trait DerivationError
    extends scala.util.control.NoStackTrace
    with Product
    with Serializable
private[demo] object DerivationError {
  final case class UnsupportedType(typeName: String) extends DerivationError
  ... // other cases
}
--

[.small]
[source, scala]
--
private def deriveOrFail[A: Type](value: Expr[A]): Expr[String] =
  Log.namedScope(s"Derivation for Show[${Type.prettyPrint[A]}]") {
    attemptAllRules[A](value) // <- this is the core of the logic
  }
  .expandFinalResultOrFail(s"Show[${Type.prettyPrint[A]}]") {
      (errorLogs, errors) =>
    val errorsStr = errors.toVector.map {
      case DerivationError.UnsupportedType(typeName) =>
        s"Derivation of $typeName is not supported"
      ... // other cases
      case e =>
        s"Unexpected error: ${e.getMessage}:\n${e.getStackTrace.mkString("\n")}"
    }.mkString("\n")

    s"""Failed to derive Show[${Type.prettyPrint[A]}]:
       |$errorsStr
       |Error logs:
       |$errorLogs
       |""".stripMargin
  }
--

=== !

[.small]
[source, scala]
--
/** Idea:
  *   - successful Some -> rule applies, attempt succeeded
  *   - successful None -> rule doesn't apply, we should try the next one
  *   - failure -> rule applies but it failed, we should fail the whole derivation
  * If none of the rules matched, then we fail derivation as well.
  */
private type Attempt[A] = MIO[Option[Expr[A]]]
--

[.small]
[source, scala]
--
private def attemptAllRules[A: Type](value: Expr[A]): MIO[Expr[String]] =
  MIO.async { await =>
    await {
      attemptUsingImplicit[A](value)
    } orElse await {
      attemptAsBuiltIn[A](value)
    } orElse await {
      attemptAsIterable[A](value)
    } orElse await {
      attemptAsCaseClass[A](value)
    } orElse await {
      attemptAsEnum[A](value)
    } getOrElse await {
      MIO.fail(DerivationError.UnsupportedType(Type.prettyPrint[A]))
    }
  }
--

[.small]
[source, scala]
--
private def attemptUsingImplicit[A: Type](value: Expr[A]): Attempt[String] = ...

private def attemptAsBuiltIn[A: Type](value: Expr[A]): Attempt[String] = ...

private def attemptAsIterable[A: Type](value: Expr[A]): Attempt[String] = ...

private def attemptAsCaseClass[A: Type](value: Expr[A]): Attempt[String] = ...

private def attemptAsEnum[A: Type](value: Expr[A]): Attempt[String] = ...
--

=== !

[.small]
[source, scala]
--
/** Enables logging if we either:
  *   - import [[demo.debug.logDerivation]] in the scope
  *   - have set scalac option `-Xmacro-settings:show.logDerivation=true`
  */
private def shouldWeLogDerivation: Boolean = {
  implicit val LogDerivation: Type[Show.LogDerivation] = Types.LogDerivation
  def logDerivationImported = Expr.summonImplicit[Show.LogDerivation].isDefined

  def logDerivationSetGlobally = (for {
    data <- Environment.typedSettings.toOption
    show <- data.get("show")
    shouldLog <- show.get("logDerivation").flatMap(_.asBoolean)
  } yield shouldLog).getOrElse(false)

  logDerivationImported || logDerivationSetGlobally
}
--

[.small]
[source, scala]
--
// ...
.expandFinalResultOrFail(
   s"Show[${Type.prettyPrint[A]}]"
   renderInfoLogs = shouldWeLogDerivation) { // <- enable conditional logging
// ...
--

TODO: screeny

== Summary
