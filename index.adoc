// 35 minutes
:revealjs_totalTime: 1800
:revealjs_theme: serif
:revealjs_help: true

[.small]
= Can we have the{nbsp}Standard Library for{nbsp}Macros?

---

**Mateusz Kubuszok**

[NOTE.speaker]
--
Before answering the question in the title, we need to explain a few more things.
--

== What is a Macro?

[NOTE.speaker]
--
First of all, what is a{nbsp}macro?
--

=== !

[%step]
 * a code generator
 * run during compilation by the compiler
 * working on the AST
 * _pretending_ to be a method
 * `Mirror` s, `inline if` s, `inline match` , `summonInline` , `summonFrom` , ... - metaprogramming but not macros

[NOTE.speaker]
--
...in other words the thing in the next slide.
--

=== !

[.small]
[source, scala]
--
// Scala 2
import scala.language.experimental.macros

def macroMethod[A](a: A): SthOf[A] =
  macro macroMethodImpl[A]

import scala.reflect.macros.blackbox

def macroMethodImpl[A: c.WeakTypeTag](
  c: blackbox.Context
)(a: c.Expr[A]): c.Expr[SthOf[A]] = {
  import c.universe._
  ...
}
--

[.small]
[source, scala]
--
// Scala 3
import scala.quoted.*

inline def macroMethod[A](a: A): SthOf[A] =
  ${ macroMethodImpl[A]('{ a }) }

def macroMethodImpl[A: Type](
  using q: Quotes
)(a: Expr[A]): Expr[SthOf[A]] = {
  import q.reflect.*
  ...
}
--

[NOTE.speaker]
--
This is what I would mean, when I am talking about macros.
--

== Why do we need macros?

[NOTE.speaker]
--
Perhaps we don't, and this whole presentation is pointless.

What alternatives we have?
--

=== Alternatives

[%step]
 * Shapeless (Scala 2)
 * `inline` , Mirrors & `scala.compiletime` (Scala{nbsp}3)
 * Magnolia (Scala 2 & 3)
 * runtime reflection
 
[NOTE.speaker]
--
`Shapeless` and `Mirror` s, usually both rely on summoning implicits, and we end up doing a prolog-like programming with method signatures. 

Magnolia on Scala 2 requires calling a macro, but we don't need to write it, we write some runtime methods.

Runtime moves all magic to the runtime, so we have to run the code to make sure it works.

All 4 of them have gentler learning curves that macros, which is why tutorials favor them.

And why especially the first 3 dominated the Scala ecosystem.
--

=== But

=== !

(slajd na przykłady z errorami, benchmarkami kompilacji i runtime)

=== !

(slajd na przykład z logami z makra)

=== In other words

=== Shapeless/Mirrors/etc

[cols="1,1"]
|===
| You
| Your users
a|
[%step]
 * easy start
 * rapid development
 * everything feels lean
 * everything feels prinicipled and correct
a|
[%step]
 * pay with longer compilation times
 * pay with less performant runtime
 * pay with more time spend if the code doesn't work
|===

[NOTE.speaker]
--
When I look at this, and think of all the popular libraries based on that, I feel like they are:

 * widely-adopted
 * feature-rich
 * proof-of-concept-level quality
 * liabilities
--

=== Macros

[.small]
[cols="1,1"]
|===
| You
| Your users
a|
[%step]
 * longer setup
 * no batteries included
 * development feel clunky
 * everything feels like a hack
a|
[%step]
 * _may_ get better compilation times (than alternatives)
 * _may_ get more performant runtime
 * _may_ get better errors messages
 * *or* may get an undebugabble mess that cannot be understood even by the author
|===

[NOTE.speaker]
--
(Between *may* and *or*) - and our users deserve it!

So this on the other hands is like a hazard game.

If you want to provide:
 * nice compilation times
 * nice runtime performance
 * nice errors messages and debugging experience

then macros are the only game in town.

But with no guarantee of success.

It may sound unfounded, especially since Scala 3 macros are supposedly principled, so let's take a look at some examples.
--

== Macros API

**Opportunities for improvement**

=== Quoting and Splicing

[cols="1,1"]
|===
| Scala 2 (Quasiquotes)
| Scala 3 (Quotes)
a|
[source, scala]
--
// using Quotes
val expr1 =
  c.Expr[Int](q"21")
val expr2 =
  c.Expr[Int](q"37")

val expr3 = c.Expr[Int](
  q"""
  ${ expr1 } + ${ expr2 }
  """
)
--
a|
[source, scala]
--
// using Quotes
val expr1 = Expr(21)
val expr2 = Expr(37)

val expr3 = '{
  ${ expr1 } + ${ expr2 }
}
--
|===

[NOTE.speaker]
--
On Scala 2, if we want to use types, we are very verbose.

Types are not inferred, and we have to use `c.Type` and `c.Expr` to get them.

Quasiquotes are basically compile-time-checked string interpolation,
so even though they are powerful and usually safe,
we have no syntax highlighting, nor intellisense when writing them.

On Scala 3, we have some actual quotes, which works bettern with IDE.

So, this looks like an issue only for Scala 2.
--

=== Matching Types

[.small]
[cols="1,1"]
|===
| Scala 2 (Quasiquotes)
| Scala 3 (Quotes)
a|
[source, scala]
--
def whenOptionOf[A:c.WeakTypeTag] =...

weakTypeOf[A]
 .dealias
 .widen
 .baseType(
  c.mirror.staticClass("scala.Option")
 ) match {
  case TypeRef(_, _, List(t)) =>
    whenOptionOf(
      c.WeakTypeTag(t.dealias.widen)
    )
  case _ => ...
}
--
a|
[source, scala]
--
def whenOptionOf[A: Type] = ...

Type.of[A] match {
  case '[Option[t]] =>
    whenOptionOf[t]
  case _ => ...
}
--
|===

[NOTE.speaker]
--
We want to pattern match on types. Is the type `A` an example of an `Option`?
We also want to handle cases like `None`.

The Scala 2 snippet barely fit in the table.

Scala 3 is quotes easy to read.
--

=== Instantiating an{nbsp}Arbitrary Type

[cols="1,1"]
|===
| Scala 2 (Quasiquotes)
| Scala 3 (Quotes)
a|
[source, scala]
--
val args:List[List[c.Tree]]=
  ...

c.Expr[A](
  q"""
  new ${weakTypeOf[A]}(
    ...${args}
  )
  """
)
--
a|
[source, scala]
--
val ctor = TypeRepr.of[A]
  .typeSymbol
  .primaryConstructor

val args: List[List[Tree]] =
  ...

New(TypeTree.of[A])
  .select(ctor)
  .appliedToArgss(args)
--
|===

[NOTE.speaker]
--
Scala 2 is not perfect, we're gluing untyped `Tree`s, but at least it's consistent.

Scala 3, allows quoting and splicing, but only for whole expressions. Pieces that would build an expression have to be combined manually.
--

=== Constructing a Pattern Match

[.small]
[cols="1,1"]
|===
| Scala 2 (Quasiquotes)
| Scala 3 (Quotes)
a|
[source, scala]
--
def handleCase[
  A: c.WeakTypeTag
](name: c.Expr[A]) = ...
--

[source, scala]
--
/* for each case: */
val name = c.internal
  .reificationSupport
  .freshTermName("a")
cq"""
$name: ${weakTypeOf[A]} =>
  ${handleCase(c.Expr[A](q"$name"))}
"""
--

[source, scala]
--
/* then create the match: */
c.Expr[Result](
  q"""
  $expr match { ...${cases} }
  """
)
--
a|
[source, scala]
--
def handleCase[
  A: Tag
](name: Expr[A]) = ...
--

[source, scala]
--
/* for each case: */
val name = Symbol.newBind(
  Symbol.spliceOwner,
  Symbol.freshName("a"),
  Flags.Empty,
  TypeRepr.of[A]
)
CaseDef(
  Bind(
    name,
    Typed(Wildcard(),TypeTree.of[A])),
  None,
  handleCase(Ref(name).asExprOf[A]))
--

[source, scala]
--
Match(expr.asTerm, cases)
  .asExprOf[Result]
--
|===

[NOTE.speaker]
--
Scala 2, again, not perfect, but consistent. We can actually read the code and understand what's going on.

Scala 3, we can get easily lost with the details.

And, these are not even bullet-proof:
for some cases such match would work, but for some it would not,
so we would have to write multiple versions and check which applies.
--

=== Sealed Trait's Children

[.small]
[cols="1,1"]
|===
| Scala 2 (Quasiquotes)
| Scala 3 (Quotes)
a|
[source, scala]
--
TODO
--
a|
[source, scala]
--
TODO
--
|===

[NOTE.speaker]
--

--

=== !

[.small]
[cols="1,1"]
|===
| Scala 2 (Quasiquotes)
| Scala 3 (Quotes)
a|
[%step]
 * glueing strings instead of typed code
 * but at least these string resemble the real code
 * and compiler checks them
a|
[%step]
 * gluing expressions as every other real code
 * but it's not an expression, we are gluing together untyped trees
|===

[NOTE.speaker]
--
It seems that the API is lacking.

What other issues we might have?
--

== No `println` debugging

[.small]
[cols="1,1"]
|===
| Macro reporting
a| `println`
a|
[source, scala]
--
c.echo("msg") // Scala 2
report.info("msg") // Scala 3
--
a|
[source, scala]
--
println("msg")
--
a|
[%step]
 * works in the terminal
 * works in the IDE
 * works in Scastie
 * logs only the first message from the macro
a|
[%step]
 * prints every time
 * works only in the terminal
 * unless we are using some compilation server
|===

[NOTE.speaker]
--
Macros on both Scala 2 and 3 have reporting mechanisms, which allow showing some hints in the terminal, or in the IDE, or even Scastie.

But if we use `println`, it works only in the terminal. And only if we are not using some compilation server.

Problem with the macro reporting API, is that only the first message is shown.

So, we would have to aggregate the messages somehow, before calling the API only once.
--

== Avoiding runtime dependencies in macros

[%step]
 * no Cats
 * no ZIO
 * nor any other library, that could be used in runtime

[NOTE.speaker]
--
It would be silly if some of our code stopped compiling, because there was a major release of a large library, that we used in some other part of our code.
Or the opposite, if the author of macros forced us to update our dependancy to a new major version, just to fix an unrelated bug.

Unless macro creates a value type that comes from some library used in runtime, it should not have dependency on that library.

But it we had a library that is not intended for runtime, then there is no conflict.
--

== Let us imagine a better API

=== Macro IO

TODO: first off, MIO

=== Logging

=== Let's assume that it can be a thing

TODO: for now let's use that pseudocode syntax for quotes

=== !

TODO: extracting types and matching them

=== ! 

TODO: calling ctors and methods

=== !

TODO: pattern matching on subtypes

== Actually, it's already possible

demo example

== Summary
